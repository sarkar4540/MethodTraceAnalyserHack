/*
 * Copyright 2019 Aniruddha Sarkar.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.altcodelabs.methodtrace.analyser;

import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.Vector;
import javax.swing.AbstractAction;
import javax.swing.BorderFactory;
import javax.swing.DefaultListModel;
import javax.swing.JEditorPane;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.JTree;
import javax.swing.JViewport;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;
import javax.swing.table.TableRowSorter;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.TreePath;
import name.fraser.neil.plaintext.diff_match_patch;
import name.fraser.neil.plaintext.diff_match_patch.Diff;

/**
 * The main window of the application.
 *
 * @author ani
 */
public class MainFrame extends javax.swing.JFrame {

    /**
     * Creates new form MainFrame
     */
    TraceManager traceManager;

    public MainFrame() {
        initComponents();
        traceManager = new TraceManager();
        updateWorking(true);
        new Thread(() -> {
            loadTraces();
            updateWorking(false);
        }).start();
    }

    private int waitLevel = 0;

    /**
     * Updates the working state of the application, and displays the
     * corresponding state.
     *
     * @param entry true if a new task is initiated, false if a task is
     * completed.
     */
    private void updateWorking(boolean entry) {
        if (entry) {
            waitLevel++;
        } else {
            waitLevel--;
        }
        if (waitLevel == 0) {
            jLabel1.setText("");
            this.setCursor(Cursor.getDefaultCursor());
        } else {
            jLabel1.setText("Performing " + waitLevel + " task(s)...");
            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPopupMenu1 = new javax.swing.JPopupMenu();
        jMenuItem7 = new javax.swing.JMenuItem();
        jLabel1 = new javax.swing.JLabel();
        jSplitPane2 = new javax.swing.JSplitPane();
        jScrollPane2 = new javax.swing.JScrollPane();
        jList2 = new javax.swing.JList<>();
        jTabbedPane2 = new javax.swing.JTabbedPane();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jButton5 = new javax.swing.JButton();
        jButton6 = new javax.swing.JButton();
        jButton7 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenuItem3 = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenu3 = new javax.swing.JMenu();
        jMenuItem2 = new javax.swing.JMenuItem();
        jMenuItem5 = new javax.swing.JMenuItem();
        jMenuItem4 = new javax.swing.JMenuItem();
        jMenuItem6 = new javax.swing.JMenuItem();
        jMenuItem8 = new javax.swing.JMenuItem();

        jMenuItem7.setText("Search");
        jMenuItem7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem7ActionPerformed(evt);
            }
        });
        jPopupMenu1.add(jMenuItem7);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Method Trace Analyser");
        addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                formFocusGained(evt);
            }
        });

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);

        jSplitPane2.setDividerLocation(200);

        jList2.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = { "Item 1", "Item 2", "Item 3", "Item 4", "Item 5" };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        jList2.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jList2FocusGained(evt);
            }
        });
        jList2.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jList2MouseClicked(evt);
            }
        });
        jScrollPane2.setViewportView(jList2);

        jSplitPane2.setLeftComponent(jScrollPane2);
        jSplitPane2.setRightComponent(jTabbedPane2);

        jButton1.setText("Import Trace");
        jButton1.setToolTipText("Import a binary trace output file.");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setText("Run with Tracing");
        jButton2.setToolTipText("Run a java project or class with Xtrace option enabled, to obtain trace files.");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton5.setText("Compute Difference");
        jButton5.setToolTipText("Compare the selected traces using one of the methods available.");
        jButton5.setEnabled(false);
        jButton5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton5ActionPerformed(evt);
            }
        });

        jButton6.setText("Run SQL");
        jButton6.setToolTipText("Run a sql syntax over current trace.");
        jButton6.setEnabled(false);
        jButton6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton6ActionPerformed(evt);
            }
        });

        jButton7.setText("Close Tab");
        jButton7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton7ActionPerformed(evt);
            }
        });

        jButton3.setText("Method Tree");
        jButton3.setToolTipText("Show method tree of the current trace.");
        jButton3.setEnabled(false);
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jButton4.setText("Method Stats");
        jButton4.setToolTipText("Show method statistics (invocations count) of the current trace, or of the selected traces (if multiple traces are selected).");
        jButton4.setEnabled(false);
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jMenu1.setText("File");

        jMenuItem3.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_I, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem3.setText("Import Trace File(s)...");
        jMenuItem3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem3ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem3);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");

        jMenuItem1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_P, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem1.setText("Preferences");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItem1);

        jMenuBar1.add(jMenu2);

        jMenu3.setText("Tools");

        jMenuItem2.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_T, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem2.setText("Run with Trace");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jMenu3.add(jMenuItem2);

        jMenuItem5.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem5.setText("Run SQL");
        jMenuItem5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem5ActionPerformed(evt);
            }
        });
        jMenu3.add(jMenuItem5);

        jMenuItem4.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_T, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem4.setText("Method Tree");
        jMenuItem4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem4ActionPerformed(evt);
            }
        });
        jMenu3.add(jMenuItem4);

        jMenuItem6.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_K, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem6.setText("Method Stats");
        jMenuItem6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem6ActionPerformed(evt);
            }
        });
        jMenu3.add(jMenuItem6);

        jMenuItem8.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_D, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem8.setText("Compute Difference");
        jMenuItem8.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem8ActionPerformed(evt);
            }
        });
        jMenu3.add(jMenuItem8);

        jMenuBar1.add(jMenu3);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jSplitPane2, javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(jButton1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton6)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jButton7))
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton1)
                    .addComponent(jButton2)
                    .addComponent(jButton5)
                    .addComponent(jButton6)
                    .addComponent(jButton7)
                    .addComponent(jButton3)
                    .addComponent(jButton4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSplitPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 412, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Shows preferences editor for the application.
     *
     * @param evt The triggering event
     */
    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        PreferencesFrame pf = new PreferencesFrame(true);
        pf.setVisible(true);
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    /**
     * Show "run using trace" window.
     *
     * @param evt The triggering event
     */
    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
        new RunTrace().setVisible(true);
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    /**
     * Imports a binary trace file to a format suitable working with this
     * application.
     *
     * @param evt The triggering event
     */
    private void jMenuItem3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem3ActionPerformed
        JFileChooser jfc = new JFileChooser();
        jfc.setMultiSelectionEnabled(true);
        if (jfc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File[] file = jfc.getSelectedFiles();
            String name1 = JOptionPane.showInputDialog("Enter a name for the trace:", file[0].getName());
            updateWorking(true);
            new Thread(() -> {
                if (!traceManager.importTrace(Arrays.asList(file), name1)) {
                    JOptionPane.showMessageDialog(this, "There was an error importing the binary trace files.");
                }
                loadTraces();
                updateWorking(false);
            }).start();
        }
    }//GEN-LAST:event_jMenuItem3ActionPerformed

//    Updates the row heights to maximum of a JTable
//    private void updateRowHeights(JTable table) {
//        for (int row = 0; row < table.getRowCount(); row++) {
//            int rowHeight = table.getRowHeight();
//
//            for (int column = 0; column < table.getColumnCount(); column++) {
//                Component comp = table.prepareRenderer(table.getCellRenderer(row, column), row, column);
//                rowHeight = Math.max(rowHeight, comp.getPreferredSize().height);
//            }
//
//            table.setRowHeight(row, rowHeight);
//        }
//    }

    List<TraceManager.MethodTrace> method_traces;
    String name;
    boolean runSQL = false, methodTree = false, methodStats = false, computeDifference = false;

    /**
     * Listens to the click event of jList2 and activates corresponding buttons;
     * if double click is detected, the info of the corresponding trace is
     * shown.
     *
     * @param evt The triggering event The mouse event of jList2
     */
    private void jList2MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jList2MouseClicked
        if (evt.getClickCount() == 2) {
            switch (evt.getButton()) {
                case 1:
                    updateWorking(true);
                    new Thread(() -> {
                        name = jList2.getSelectedValue();
                        setTitle("Method Trace Analyser - " + name);
                        if (name != null) {
                            JTextArea area = new JTextArea();
                            area.setText(traceManager.getInfo(name));
                            area.setEditable(false);
                            jTabbedPane2.add(name + " - info", new JScrollPane(area));
                            runSQL = true;
                            methodTree = true;
                            methodStats = true;
                        }
                        updateWorking(false);
                    }).start();
                    break;
                case 3:

            }
        }
        if (evt.getClickCount() == 1) {
            if (jList2.getSelectedIndices().length > 0) {
                methodTree = true;
                methodStats = true;
            } else {
                methodTree = false;
                methodStats = false;
            }
            runSQL = jList2.getSelectedIndices().length == 1;
            switch (jList2.getSelectedIndices().length) {
                default:
                    computeDifference = false;
                    break;
                case 2:
                    computeDifference = true;
                    break;
            }
        }
        jButton5.setEnabled(computeDifference);
        jButton6.setEnabled(runSQL);
        jButton3.setEnabled(methodTree);
        jButton4.setEnabled(methodStats);
    }//GEN-LAST:event_jList2MouseClicked
    HashMap<String, Integer> tabMap = new HashMap();

    /**
     * Adds a tab with a table to the jTabbedPane2
     *
     * @param model the TableModel to be displayed
     * @param name The name of the tab
     */
    private void showTableTab(TableModel model, String name) {
        JTable table = new JTable();
        table.setModel(model);
        table.addMouseListener(new TableSearchAdapter());
        TableRowSorter<TableModel> sorter = new TableRowSorter<>(model);
        table.setRowSorter(sorter);

        jTabbedPane2.setSelectedComponent(jTabbedPane2.add(name, new JScrollPane(table)));
    }
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        jMenuItem3ActionPerformed(evt);
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        jMenuItem2ActionPerformed(evt);
    }//GEN-LAST:event_jButton2ActionPerformed

    /**
     * Run SQL commands on the selected trace's database.
     *
     * @param evt The triggering event
     */
    private void jButton6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton6ActionPerformed
        String sql = JOptionPane.showInputDialog("Enter the SQL command", "SELECT * FROM point WHERE component='mt';");
        String name1 = jList2.getSelectedValue();
        if (name1 != null && sql != null) {
            updateWorking(true);
            new Thread(() -> {
                TableModel model = traceManager.runSQL(name1, sql);
                if (model != null) {
                    showTableTab(model, name1 + " - sql");
                } else {
                    JOptionPane.showMessageDialog(this, "There was an error while running SQL command. Please check your SQL syntax.");
                }
                updateWorking(false);
            }).start();
        }
    }//GEN-LAST:event_jButton6ActionPerformed

    private void jMenuItem5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem5ActionPerformed
        jButton6ActionPerformed(evt);
    }//GEN-LAST:event_jMenuItem5ActionPerformed

    private void formFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_formFocusGained


    }//GEN-LAST:event_formFocusGained
    /**
     * Loads the traces when jList2 gains focus
     * @param evt The triggering event 
     */
    private void jList2FocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jList2FocusGained

        updateWorking(true);
        new Thread(() -> {
            loadTraces();
            updateWorking(false);
        }).start();
    }//GEN-LAST:event_jList2FocusGained

    /**
     * Allows a JTable to have search option upon right click.
     */
    class TableSearchAdapter extends MouseAdapter implements MouseListener {

        String lastSearch;

        @Override
        public void mouseClicked(MouseEvent e) {
            super.mouseClicked(e);
            if (e.getButton() == 3) {
                JTable c = (JTable) e.getComponent();
                JPopupMenu menu = new JPopupMenu("Table");
                menu.add(new AbstractAction("Search " + c.getColumnName(c.getSelectedColumn())) {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        updateWorking(true);
                        String q = JOptionPane.showInputDialog("Enter the search term (RegEx allowed):", lastSearch == null ? "" : lastSearch);
                        lastSearch = q;
                        if (q != null) {
                            new Thread(() -> {
                                TableModel model = c.getModel();
                                int i = c.getSelectedColumn(), r = model.getRowCount();
                                for (int j = c.getSelectedRow() + 1; j < r; j++) {
                                    if (model.getValueAt(j, i).toString().matches(q) || model.getValueAt(j, i).toString().equals(q)) {
                                        c.setRowSelectionInterval(j, j);
                                        scrollToVisible(c, j, i);
                                        break;
                                    }
                                }
                                updateWorking(false);
                            }).start();
                        }
                    }

                });
                menu.show(c, e.getX(), e.getY());
            }

        }

    }

    /**
     * Scrolls JTable such that the corresponding cell is visible.
     * @param table  the JTable
     * @param rowIndex the row index of the cell
     * @param vColIndex the column index of the cell
     */
    public static void scrollToVisible(JTable table, int rowIndex, int vColIndex) {
        if (!(table.getParent() instanceof JViewport)) {
            return;
        }
        JViewport viewport = (JViewport) table.getParent();
        Rectangle rect = table.getCellRect(rowIndex, vColIndex, true);
        Point pt = viewport.getViewPosition();
        rect.setLocation(rect.x - pt.x, rect.y - pt.y);
        viewport.scrollRectToVisible(rect);
    }
    private void jMenuItem7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem7ActionPerformed
       
    }//GEN-LAST:event_jMenuItem7ActionPerformed

    /**
     * Computes difference of the selected traces.
     * @param evt The triggering event 
     */
    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton5ActionPerformed

        updateWorking(true);
        new Thread(() -> {
            int[] indices = jList2.getSelectedIndices();
            if (indices.length == 2) {
                String names[] = new String[]{jList2.getModel().getElementAt(indices[0]), jList2.getModel().getElementAt(indices[1])},
                        mt1 = traceManager.getMethodTrace(names[0], true),
                        mt2 = traceManager.getMethodTrace(names[1], true);
                //System.out.println(mt1+" \n\n"+mt2);
                Vector<Vector<String>> data = new Vector<>();
                Vector<String> columns = new Vector<>();
                columns.add(names[0]);
                columns.add("common");
                columns.add(names[1]);
                diff_match_patch dmp = new diff_match_patch();
                diff_match_patch.LinesToCharsResult res = dmp.diff_linesToChars(mt1, mt2);
                LinkedList<Diff> diffs = dmp.diff_main(res.chars1, res.chars2, false);
                dmp.diff_charsToLines(diffs, res.lineArray);
                Diff l_diff = null;
                for (Diff diff : diffs) {
                    diff.text = diff.text.replaceAll("[\n]", "\\\\n");
                    if (diff.operation.equals(diff_match_patch.Operation.EQUAL)) {
                        Vector<String> row = new Vector<>();
                        row.add("");
                        row.add(diff.text);
                        row.add("");
                        data.add(row);
                    }
                    if (diff.operation.equals(diff_match_patch.Operation.DELETE) || diff.operation.equals(diff_match_patch.Operation.INSERT)) {
                        Vector<String> row = null;
                        if (l_diff != null) {
                            if (!l_diff.operation.equals(diff.operation) && (l_diff.operation.equals(diff_match_patch.Operation.DELETE) || l_diff.operation.equals(diff_match_patch.Operation.INSERT))) {
                                row = data.lastElement();
                                if (l_diff.operation.equals(diff_match_patch.Operation.INSERT)) {
                                    row.set(0, diff.text);
                                }
                                if (l_diff.operation.equals(diff_match_patch.Operation.DELETE)) {
                                    row.set(2, diff.text);
                                }
                            }
                        }
                        if (row == null) {
                            row = new Vector<>();
                            row.add(diff.operation.equals(diff_match_patch.Operation.DELETE) ? diff.text : "");
                            row.add("");
                            row.add(diff.operation.equals(diff_match_patch.Operation.INSERT) ? diff.text : "");
                            data.add(row);
                        }
                    }
                    l_diff = diff;

                }
                /*
                //Uses DiffUtils API, requires artifact diff-utils-1.2.jar
                Vector<Vector<String>> data = new Vector<>();
                Vector<String> columns = new Vector<>();
                columns.add(names[0]);
                columns.add(names[1]);
                for (Delta diff : DiffUtils.diff(Arrays.asList(mt1.split("\n")), Arrays.asList(mt2.split("\n"))).getDeltas()) {
                    Vector<String> fdiff = new Vector<>();
                    String orig = "", rev = "";
                    for(Object obj:diff.getOriginal().getLines()){
                        orig+=obj.toString()+"\n";
                    }
                    for(Object obj:diff.getRevised().getLines()){
                        rev+=obj.toString()+"\n";
                    }
                    fdiff.add(orig);
                    fdiff.add(rev);
                    data.add(fdiff);
                }*/
                JTable table = new JTable(data, columns);
                TableColumnModel model = table.getColumnModel();
                TextAreaCellRenderer renderer = new TextAreaCellRenderer();
                model.getColumn(0).setCellRenderer(renderer);
                model.getColumn(1).setCellRenderer(renderer);
                model.getColumn(2).setCellRenderer(renderer);
                jTabbedPane2.setSelectedComponent(jTabbedPane2.add(names[0] + " " + names[1] + " - difference", new JScrollPane(table)));

            }
            updateWorking(false);
        }).start();
    }//GEN-LAST:event_jButton5ActionPerformed

    /**
     * TextAreaCellRenderer Used to show multiline cells in a JTable, with
     * automatic height allocation. Collected from:
     * obtained from http://blog.botunge.dk/post/2009/10/09/JTable-multiline-cell-renderer.aspx
     */
    private class TextAreaCellRenderer extends JTextArea implements TableCellRenderer {

        private final List< List< Integer>> rowAndCellHeightList = new ArrayList<>();

        @Override
        public void updateUI() {
            super.updateUI();
            setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));
            setName("Table.cellRenderer");
        }

        @Override
        public Component getTableCellRendererComponent(
                JTable table, Object value, boolean isSelected, boolean hasFocus,
                int row, int column) {
            setFont(table.getFont());
            setText(Objects.toString(value, "").replaceAll("(\\\\+n)", "\n"));
            adjustRowHeight(table, row, column);
            return this;
        }

        /**
         * Calculate the new preferred height for a given row, and sets the
         * height on the table.
         *
         */
        private void adjustRowHeight(JTable table, int row, int column) {
            // The trick to get this to work properly is to set the width of the column to the
            // textarea. The reason for this is that getPreferredSize(), without a width tries
            // to place all the text in one line. By setting the size with the with of the column,
            // getPreferredSize() returnes the proper height which the row should have in
            // order to make room for the text.
            // int cWidth = table.getTableHeader().getColumnModel().getColumn(column).getWidth();
            // int cWidth = table.getCellRect(row, column, false).width; //Ignore IntercellSpacing
            // setSize(new Dimension(cWidth, 1000));

            setBounds(table.getCellRect(row, column, false));
            // doLayout();

            int preferredHeight = getPreferredSize().height;
            while (rowAndCellHeightList.size() <= row) {
                rowAndCellHeightList.add(new ArrayList<>(column));
            }
            List<Integer> cellHeightList = rowAndCellHeightList.get(row);
            while (cellHeightList.size() <= column) {
                cellHeightList.add(0);
            }
            cellHeightList.set(column, preferredHeight);
            int max = cellHeightList.stream().max(Integer::compare).get();
            if (table.getRowHeight(row) != max) {
                table.setRowHeight(row, max);
            }
        }
    }
    
    /**
     * Generates method tree of the selected trace(s).
     * @param evt The triggering event 
     */
    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed

        updateWorking(true);
        new Thread(() -> {
            String title = "method tree - ";
            int[] indices = jList2.getSelectedIndices();
            String[] names = null;
            if (indices.length > 0) {
                names = new String[indices.length];

                for (int i = 0; i < indices.length; i++) {
                    names[i] = jList2.getModel().getElementAt(indices[i]);
                    title += names[i] + " ";
                }
            } else if (name != null) {
                names = new String[]{name};
                title += name + " ";
            }

            if (names != null) {
                ArrayList<Component> components = new ArrayList<>();
                for (String name_t : names) {
                    method_traces = traceManager.getMethodTrace(name_t);
                    System.out.println(method_traces);
                    TraceManager.MethodTrace last_method_trace = new TraceManager.MethodTrace();

                    JTree.DynamicUtilTreeNode root = new JTree.DynamicUtilTreeNode(last_method_trace, null), last = root;
                    last_method_trace.className = "METHOD CALLS - " + name_t;
                    last_method_trace.isCompleted = true;
                    last_method_trace.hasException = false;
                    last_method_trace.stack_level = -1;
                    long sum_runtime = 0;
                    int count_runtime = 0;
                    for (TraceManager.MethodTrace method_trace : method_traces) {
                        sum_runtime += method_trace.timeOut - method_trace.timeIn;
                        count_runtime++;
                    }
                    if (count_runtime != 0) {
                        final long avg_runtime = sum_runtime / count_runtime;
                        for (TraceManager.MethodTrace method_trace : method_traces) {
                            while (method_trace.stack_level <= last_method_trace.stack_level) {
                                JTree.DynamicUtilTreeNode parent = (JTree.DynamicUtilTreeNode) last.getParent();
                                if (parent != null) {
                                    last = parent;
                                    last_method_trace = (TraceManager.MethodTrace) last.getUserObject();
                                } else {
                                    break;
                                }

                            }
                            if (method_trace.stack_level > last_method_trace.stack_level) {
                                JTree.DynamicUtilTreeNode node = new JTree.DynamicUtilTreeNode(method_trace, null);
                                if (!last.getAllowsChildren()) {
                                    last.setAllowsChildren(true);
                                }
                                last.add(node);
                                node.setParent(last);
                                last = node;
                                last_method_trace = method_trace;
                            }

                        }
                        JTree jtree1 = new JTree(root);
                        
                        //Uses JLabel as cell component for applying various text styles using html.
                        DefaultTreeCellRenderer renderer = new DefaultTreeCellRenderer() {
                            @Override
                            public Component getTreeCellRendererComponent(JTree tree,
                                    Object value, boolean sel, boolean expanded, boolean leaf,
                                    int row, boolean hasFocus) {
                                super.getTreeCellRendererComponent(tree, value, sel, expanded,
                                        leaf, row, hasFocus);

                                final TraceManager.MethodTrace methodTrace = (TraceManager.MethodTrace) (((JTree.DynamicUtilTreeNode) value).getUserObject());
                                long runtime = methodTrace.timeOut - methodTrace.timeIn;
                                JLabel label = new JLabel("<html><body>" + methodTrace.className.replaceAll("[<]", "&lt;").replaceAll("[>]", "&gt;") + (methodTrace.methodName != null ? " -> <i>" + methodTrace.methodName.replaceAll("[<]", "&lt;").replaceAll("[>]", "&gt;") + "</i>" : "") + (methodTrace.hasException ? ";<b> exception thrown</b>" : methodTrace.isCompleted ? "" : "; <b>incomplete execution</b>")
                                        + (runtime > avg_runtime ? "; <b>takes " + runtime + " ms to execute</b>" : ""));
                                label.setToolTipText(methodTrace.stackTrace);
                                label.setForeground(methodTrace.hasException ? Color.RED : !methodTrace.isCompleted ? Color.GRAY : Color.BLACK);
                                return label;
                            }

                        };
                        jtree1.setCellRenderer(renderer);
                        
                        //Shows detailed information and stacktrace about the method upon doubleclick.
                        jtree1.addMouseListener(new MouseAdapter() {
                            @Override
                            public void mouseClicked(MouseEvent e) {
                                if (e.getClickCount() == 2) {
                                    TreePath path = jtree1.getSelectionPath();
                                    if (path != null) {
                                        TraceManager.MethodTrace methodTrace = (TraceManager.MethodTrace) (((JTree.DynamicUtilTreeNode) path.getLastPathComponent()).getUserObject());

                                        JEditorPane area1 = new JEditorPane();
                                        area1.setContentType("text/html");
                                        area1.setText("<html<body><table><tr><td>Class</td><td> <code>" + methodTrace.className + "</code></td></tr>"
                                                + "<tr><td>Method</td><td> <code>" + (methodTrace.methodName.equals("<init>") ? "constructor" : methodTrace.methodName) + "</code></td></tr>"
                                                + "<tr><td>Method Parameters</td><td> <code>" + (methodTrace.parameters) + "</code></td></tr>"
                                                + "<tr><td>Execution Time</td><td> <code>" + (methodTrace.timeOut - methodTrace.timeIn) + " ms</code></td></tr>"
                                                + "<tr><td>Execution Started At</td><td> <code>" + (methodTrace.timeIn) + " ms</code></td></tr>"
                                                + "<tr><td>Execution Ended At</td><td> <code>" + (methodTrace.timeOut) + " ms</code></td></tr>"
                                                + "<tr><td>Stack Trace</td><td> <code>" + (methodTrace.stackTrace.replaceAll("[<]", "&lt;").replaceAll("[>]", "&gt;").replaceAll("[\n]", "<br/>")) + "</code></td></tr>");
                                        jTabbedPane2.setSelectedComponent(jTabbedPane2.add(methodTrace.className + " -> " + methodTrace.methodName, new JScrollPane(area1)));

                                    }
                                }
                            }

                        });
                        
                        //Expands all rows of the JTree
                        for (int i = 0; i < jtree1.getRowCount(); i++) {
                            jtree1.expandRow(i);
                        }
                        components.add(new JScrollPane(jtree1));
                    } else {
                        JOptionPane.showMessageDialog(MainFrame.this, "None of your selected methods got invoked in " + name_t + "!");
                    }
                }
                
                if (components.size() > 1) {
                    GridLayout grid = new GridLayout();
                    JPanel panel = new JPanel(grid);
                    for (int i = 0; i < components.size(); i++) {
                        panel.add(names[i], components.get(i));
                    }
                    jTabbedPane2.setSelectedComponent(jTabbedPane2.add(title, panel));
                } else if (components.size() == 1) {
                    jTabbedPane2.setSelectedComponent(jTabbedPane2.add(title, components.get(0)));
                }
            }
            updateWorking(false);
        }).start();
    }//GEN-LAST:event_jButton3ActionPerformed

    /**
     * Shows method statistics (number of invocations) of the selected trace(s).
     * @param evt The triggering event 
     */
    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed

        updateWorking(true);
        new Thread(() -> {
            int[] indices = jList2.getSelectedIndices();
            String title = "";
            TableModel model = null;
            if (indices.length > 0) {
                String[] names = new String[indices.length];

                for (int i = 0; i < indices.length; i++) {
                    names[i] = jList2.getModel().getElementAt(indices[i]);
                    title += names[i] + " ";
                }
                model = traceManager.getMethodStats(names);
            } else if (name != null) {
                model = traceManager.getMethodStats(name);
                title = name + " ";
            }

            if (model != null) {
                JTable table = new JTable(model);
                int max = 0;
                for (int i = 0; i < model.getRowCount(); i++) {
                    for (int j = 1; j < model.getColumnCount(); j++) {
                        int temp = Integer.parseInt(model.getValueAt(i, j).toString());
                        if (temp > max) {
                            max = temp;
                        }
                    }
                }
                final int max_final = max;
                for (int i = 1; i < model.getColumnCount(); i++) {
                    table.getColumnModel().getColumn(i).setCellRenderer(new DefaultTableCellRenderer() {
                        @Override
                        public Component getTableCellRendererComponent(JTable table,
                                Object obj, boolean isSelected, boolean hasFocus, int row, int column) {
                            return new MethodStatProgressPanel(0, max_final, Integer.parseInt(obj.toString()));
                        }
                    });
                }
                jTabbedPane2.setSelectedComponent(jTabbedPane2.add(title + " - method stats", new JScrollPane(table)));

            }

            updateWorking(false);
        }).start();
    }//GEN-LAST:event_jButton4ActionPerformed
    /**
     * Removes the selected tab from jTabbedPane2.
     *
     * @param evt The triggering event
     */
    private void jButton7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton7ActionPerformed

        if (jTabbedPane2.getComponentCount() > 0) {
            jTabbedPane2.remove(jTabbedPane2.getSelectedComponent());
        }
    }//GEN-LAST:event_jButton7ActionPerformed

    private void jMenuItem4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem4ActionPerformed
        jButton3ActionPerformed(evt);
    }//GEN-LAST:event_jMenuItem4ActionPerformed

    private void jMenuItem6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem6ActionPerformed
        jButton4ActionPerformed(evt);
    }//GEN-LAST:event_jMenuItem6ActionPerformed

    private void jMenuItem8ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem8ActionPerformed
        jButton5ActionPerformed(evt);
    }//GEN-LAST:event_jMenuItem8ActionPerformed
    /**
     * Lists the traces (imported) from workspace folder into jList2.
     */
    private void loadTraces() {

        traceManager.loadTraces();
        DefaultListModel model = new DefaultListModel();
        traceManager.connects.keySet().forEach((String str) -> {
            model.addElement(str);
        });
        jList2.setModel(model);
    }

    /**
     * The main method of the application.
     *
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        Preferences pref = Preferences.getPreferences();
        if (pref.loadPreferences()) {
            java.awt.EventQueue.invokeLater(() -> {
                new MainFrame().setVisible(true);
            });
        } else {
            PreferencesFrame pf = new PreferencesFrame(false);
            pf.setVisible(true);
        }
        /* Create and display the form */
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JButton jButton5;
    private javax.swing.JButton jButton6;
    private javax.swing.JButton jButton7;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JList<String> jList2;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenu jMenu3;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JMenuItem jMenuItem3;
    private javax.swing.JMenuItem jMenuItem4;
    private javax.swing.JMenuItem jMenuItem5;
    private javax.swing.JMenuItem jMenuItem6;
    private javax.swing.JMenuItem jMenuItem7;
    private javax.swing.JMenuItem jMenuItem8;
    private javax.swing.JPopupMenu jPopupMenu1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSplitPane jSplitPane2;
    private javax.swing.JTabbedPane jTabbedPane2;
    // End of variables declaration//GEN-END:variables
}
